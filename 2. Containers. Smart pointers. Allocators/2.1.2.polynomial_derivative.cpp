// task 2.1.2.
// Данный код реализует функцию вычисления производной полинома.
// Сначала подключаются необходимые заголовочные файлы:
// Когда вы пишете код на языке программирования C++ и используете функции, которые не определены в текущем файле со
// своим кодом, компилятор может сообщить вам об ошибке. Директивы #include помогают устранить эту проблему, подключив
// определение функций, содержащихся в других заголовочных файлах, которые уже имеются в стандартной библиотеке C++ или
// же написаны вами или другими разработчиками.
#include <string>  // заголовочный файл, содержащий классы для работы со строковыми данными.
#include <map>  // заголовочный файл, содержащий реализацию ассоциативного массива, который основан на принципе ключ-значение.
#include <vector> // заголовочный файл, содержащий реализацию динамического массива, также известного как вектор.
#include <sstream>  // заголовочный файл, содержащий классы для работы со строковыми потоками ввода/вывода.
#include <cctype>   // заголовочный файл, содержащий функции для обработки символов (например, проверку, является ли
                    // символ буквой или цифрой).


//Затем определяются две вспомогательные функции.
// Функция try_read_next читает следующий элемент из потока ss, который представляет собой строку с полиномом, и
// записывает его коэффициент k и степень degree. Она возвращает true, если очередной элемент был успешно прочитан и
// false, если достигнут конец строки или произошла другая ошибка.
bool try_read_next(std::istream& ss, uint64_t& degree, int64_t& k){
    char p = ss.peek();  // Получает первый символ из потока, но не извлекает его.

    // проверка на наличие данных в потоке
    if(!ss || ss.peek() == EOF)  // Проверка на достижение конца файла или происходит ли ошибка в потоке.
        return false; // при достижении конца потока или ошибки возвращает значение Ложь

    // определение знака
    int64_t mult = 1;  // Переменная для хранения знака числа.
    // Если первый символ строки является минусом, то устанавливает множитель на -1 и удаляет первый символ из потока ss.
    if(ss.peek() == '-'){
        ss.get();
        mult = -1;
    }
    // Если первый символ строки является плюсом, то устанавливает множитель на 1 и удаляет первый символ из потока ss.
    if(ss.peek() == '+'){
        ss.get();
        mult = 1;
    }

    // Считывает коэффициент k многочлена из входного потока ss, учитывая знак mult.
    // Если коэффициент записан с помощью числа, то он считывается функцией >>
    if(isdigit(ss.peek())){
        ss >> k;
        if(ss.peek() == '*'){
            ss.get();
        }
    }
    else{  // иначе присваивается значение 1.
        k = 1;
    }
    k *= mult;  // Если степень считана, умножает её на множитель mult.

    degree = 0;  // Сброс значения переменной degree в 0.

    // чтение степени
    // Если первый символ строки является символом "x", то устанавливает степень degree на 1 и удаляет символ "x" из потока ss.
    if(ss.peek() == 'x'){
        ss.get();
        degree = 1;
    }
    // Если следующий символ является символом "^", то считывает степень из потока ss.
    if(ss.peek() == '^'){
        ss.get();
        ss >> degree;
    }
    return true;  // Возвращает true, если считывание успешно выполнено.
}


// Функция find_derivative вычисляет производную полинома, заданного в виде отображения degrees, в котором ключами
// являются степени, а значениями коэффициенты.
// Данная функция находит производную многочлена с помощью map-коллекции и возвращает её в виде строки
std::string find_derivative(const std::map<uint64_t, int64_t>& degrees){
    std::stringstream result; // Создаёт объект stringstream для записи результата (в данном случае, производной многочлена).
    bool first = true;  // Инициализирует флаг первого найденного ненулевого коэффициента

    // Цикл, перебирающий все элементы map-коллекции degrees в обратном порядке (т. к. коэффициенты многочлена уже
    // отсортированы по возрастанию степеней).
    for(auto it = degrees.crbegin(); it != degrees.crend(); ++it){
        // Пропускает итерацию, если текущий элемент (коэффициент многочлена) равен нулю или если его степень равна нулю.
        if(it->first == 0 || it->second == 0){
            continue;
        }

        // Если это не первый ненулевой коэффициент и коэффициент многочлена положительный, добавляет символ "+" в строку результата.
        if(false == first && it->second > 0){
            result << '+';
        }
        first = false;  // Сбрасывает флаг первого найденного ненулевого коэффициента после первой итерации цикла.

        result << it->second * (int64_t)it->first;  // Записывает значение коэффициента многочлена, умноженное на степень текущего элемента.

        if(it->first == 1)  // Если степень текущего элемента равна 1, переходит к следующей итерации цикла.
            continue;

        if(it->first == 2){  // Если степень текущего элемента равна 2, добавляет "*x" к результату.
            result << "*x";
        }
        else{ // иначе степень текущего элемента больше 2, добавляет "*x^" и степень, уменьшенную на 1 к результату.
            result << "*x^" << it->first - 1;
        }
    }
    return result.str();  // Возвращает полученную производную многочлена в виде строки.
}



// основная функция derivative реализует алгоритм вычисления производной, используя вышеописанные функции. Она принимает
// строку polynomial, содержащую полином, и возвращает строку с производной в виде полинома.
//
// Сначала строка polynomial передаётся в поток ss, затем для каждого элемента полинома (коэффициента и степени)
// вызывается функция try_read_next. Если степень положительна, то соответствующая пара (ключ и значение) добавляется в
// карту degrees.

// Принимает на вход строку polynomial, представляющую многочлен вида "a_n*x^n + a_{n-1}x^{n-1} + ... + a_1x + a_0"
std::string derivative(std::string polynomial) {
    std::stringstream ss(polynomial);  // Создаёт объект stringstream и инициализирует его строкой polynomial.
    std::map<uint64_t, int64_t> degrees;  // Создаёт пустой map-объект degrees, который будет использоваться для хранения коэффициентов многочлена

    // Объявляет переменные degree и k, которые будут использоваться для хранения степени и коэффициента текущего элемента многочлена.
    uint64_t degree;
    int64_t k;

    // Цикл, который будет продолжаться, пока считывание следующего элемента многочлена из stringstream ss успешно (с
    // помощью вспомогательной функции try_read_next).
    while (try_read_next(ss, degree, k))
    {
        // Если степень degree нового элемента многочлена больше 0, то в map-объекте degrees увеличивается значение
        // коэффициента с ключом degree на величину k.
        if(degree > 0){
            degrees[degree] += k;
        }
    }

    // Возвращает производную многочлена, вызывая функцию find_derivative с аргументом degrees, содержащим все
    // коэффициенты многочлена, полученные из строки polynomial. Функция find_derivative вычисляет производную
    // многочлена при помощи переданного map-объекта и возвращает производную в виде строки.
    return find_derivative(degrees);
}
