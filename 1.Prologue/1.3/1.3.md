### Задание 1.3.1.
Поскольку в задании не используется неймспейс.
```C++
using namespace std;
```
то и вывести строку можно только
```
std:cout<<"hello world";
```

### Задание 1.3.2.
- В первой строке ошибка, так как название некорректное
- Вторая строка ошибочна, потому что функция должна возвращать значение
- В девятой ошибка, так как функция должна принимать два параметра, а не один

### Задание 1.3.3.
- std::map - это ассоциативный контейнер, который хранит элементы в виде пар ключ-значение, где ключи уникальны. 
Поэтому std::map представляет собой дерево.

- std::list - это контейнер, который хранит элементы в виде двусвязного списка. Поэтому std::list представляет собой 
список.

- std::array - это контейнер, который хранит элементы в виде статического массива фиксированного размера. Поэтому 
std::array представляет собой массив.

- std::unordered_map - это ассоциативный контейнер, который хранит элементы в виде пар ключ-значение, где ключи 
уникальны. Поэтому std::unordered_map представляет собой хэш-таблицу.

- std::set - это контейнер, который хранит упорядоченный набор уникальных элементов. Поэтому std::set представляет 
собой дерево.

- std::unordered_set - это контейнер, который хранит набор уникальных элементов в неупорядоченном виде. Поэтому 
std::unordered_set представляет собой хэш-таблицу.

- std::forward_list - это контейнер, который хранит элементы в виде односвязного списка. Поэтому std::forward_list 
представляет собой список.

- std::vector - это контейнер, который хранит элементы в виде динамического массива переменного размера. Поэтому 
std::vector представляет собой массив. 

### 1.3.5.
Makefile - это инструкция для системы сборки make, которая объединяет исходные файлы программы в исполняемый файл. 

В данном случае, мы собираем программу "hello" из исходных файлов "hello.c" и "hello.o". 

Порядок следования в Makefile должен соответствовать логике сборки программы. 

В данном случае, чтобы создать исполняемый файл "hello", нам нужно сначала скомпилировать исходный файл "hello.c" в 
объектный файл "hello.o" с помощью команды "$(CC) -c hello.c".  

Затем, когда у нас есть объектный файл "hello.o", мы можем создать исполняемый файл "hello" с помощью команды 
"$(CC) -o hello hello.o".  

Кроме того, мы указываем, что цель "all" зависит от цели "hello", что означает, что при выполнении команды "make 
all" будет сначала создан исполняемый файл "hello".  

Таким образом, правильная последовательность команд в Makefile для сборки программы "hello" должна быть следующей:

1. Определение переменной CC, которая содержит имя компилятора (gcc в данном случае)
2. Определение цели all, которая зависит от цели hello
3. Определение цели hello, которая зависит от цели hello.o
4. Определение цели hello.o, которая зависит от исходного файла hello.c
5. Команда для компиляции исходного файла в объектный файл: $(CC) -c hello.c
6. Команда для создания исполняемого файла из объектного файла: $(CC) -o hello hello.o 

### 1.3.6.
Если `uint32_t *i = (uint32_t*) 1024;` - корректное выражение в смысле доступности памяти по адресу 1024, то после 
операции `i++` значение указателя `i` изменится на размер `uint32_t` в байтах, так как указатель имеет тип 
`uint32_t*`.   

В типе `uint32_t` 4 байта, поэтому после выполнения операции инкремента указателя, `i` будет указывать на адрес 1028. 

Однако следует заметить, что использование чисел в кестве адресов указателей может привести к нежелательным 
результатам, поэтому такую возможность следует использовать с осторожностью.  

### 1.3.7.
 who | sort | uniq | wc -l 

 некорректно сначала делать uniq – потому что uniq заменяет элементы, повторяющиеся в списке более двух раз, на одно 
 вхождение этих элементов. Соответственно, если в списке нет дубликатов – то команды отработают одинаково, а если 
 есть (например, пользователь залогинился пять раз – то без сортировки – они могут идти в произвольном порядке и 
 команды отработают неправильно.  

Например, у нас три юзера – alex, john & mary. Первый два залогинены по одному разу, а последний – 3 раза. 
Предположим, список от вызова who – такой: 
mary
alex
john
mary
mary

Если сделать порядок uniq | sort, результат будет такой:
alex
john
mary
mary

Если сделать sort | uniq, результат такой:
alex
john
mary

Очевидно, первый вариант некорректен.

### 1.3.8. fopen против open в C

- fopen является библиотечной функцией , а open является системным вызовом .

- fopen обеспечивает буферизованный ввод-вывод , который может быть быстрее по сравнению с open небуферизованным .

- fopen является переносимым , но openне переносимым ( open зависит от среды ).

- fopen возвращает указатель на FILEструктуру ( FILE *) , а open возвращает целое число, идентифицирующее файл.

- А FILE *дает вам возможность использовать fscanf и другие stdio.h функции.

### 1.3.9.
Оптимальным алгоритмом для сортировки связных списков является сортировка слиянием (MergeSort). Этот алгоритм 
работает на основе разделения списка на половины, сортировки каждой половины отдельно, а затем слияния двух 
отсортированных списков в один отсортированный. Это позволяет сортировать связные списки с временной сложностью O(n 
log n), что является оптимальным результатом. Остальные алгоритмы, такие как сортировка вставками и сортировка 
выбором, могут работать медленнее и иметь более высокую временную сложность при сортировке связных списков.     